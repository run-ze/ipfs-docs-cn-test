<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基本示例 on IPFS Documentation</title>
    <link>https://docs.ipfs.io/guides/examples/</link>
    <description>Recent content in 基本示例 on IPFS Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	<atom:link href="https://docs.ipfs.io/guides/examples/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IPFS for Websites</title>
      <link>https://docs.ipfs.io/guides/examples/websites/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/websites/</guid>
      <description>A short guide to hosting your site on IPFS Create your site Assume you have a static website in a directory mysite.
In order to publish it as a site, make sure your ipfs daemon is running:
$ ipfs daemon  Then add the directory with your website:
$ ls mysite img index.html $ ipfs add -r mysite added QmcMN2wqoun88SVF5own7D5LUpnHwDA6ALZnVdFXhnYhAs mysite/img/spacecat.jpg added QmS8tC5NJqajBB5qFhcA1auav14iHMnoMZJWfmr4k3EY6w mysite/img added QmYh6HbZhHABQXrkQZ4aRRSoSa6bb9vaKoHeumWex6HRsT mysite/index.html added QmYeAiiK1UfB8MGLRefok1N7vBTyX8hGPuMXZ4Xq1DPyt7 mysite/  The last hash, next to the folder name, mysite/ is the one to remember, call it $SITE_CID for now.</description>
    </item>
    
    <item>
      <title>Making Your Own IPFS Service</title>
      <link>https://docs.ipfs.io/guides/examples/api/service/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/api/service/readme/</guid>
      <description>ipfs has a few default services that it runs by default, such as the dht, bitswap, and the diagnostics service. Each of these simply registers a handler on the ipfs PeerHost, and listens on it for new connections. The corenet package has a very clean interface to this functionality. So lets try building an easy demo service to try this out!
Lets start by building the service host:
package main import ( &amp;quot;fmt&amp;quot; core &amp;quot;github.</description>
    </item>
    
    <item>
      <title>Modifying the bootstrap peers list</title>
      <link>https://docs.ipfs.io/guides/examples/bootstrap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/bootstrap/</guid>
      <description>The IPFS bootstrap list is a list of peers with which the IPFS daemon learns about other peers on the network. IPFS comes with a default list of trusted peers, but you are free to modify the list to suit your needs. One popular use for a custom bootstrap list is to create a personal IPFS network.
First, let&amp;rsquo;s list your node&amp;rsquo;s bootstrap list:
&amp;gt; ipfs bootstrap list /ip4/104.131.131.82/tcp/4001/ipfs/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ /ip4/104.236.151.122/tcp/4001/ipfs/QmSoLju6m7xTh3DuokvT3886QRYqxAzb1kShaanJgW36yx /ip4/104.</description>
    </item>
    
    <item>
      <title>Pinning Files</title>
      <link>https://docs.ipfs.io/guides/examples/pinning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/pinning/</guid>
      <description>Pinning is a very important concept in ipfs. ipfs semantics try to make it feel like every single object is local, there is no &amp;ldquo;retrieve this file for me from a remote server&amp;rdquo;, just ipfs cat or ipfs get which act the same way no matter where the actual object is located. While this is nice, sometimes you want to be able to control what you keep around. Pinning is the mechanism that allows you to tell ipfs to always keep a given object local.</description>
    </item>
    
    <item>
      <title>Playing Videos</title>
      <link>https://docs.ipfs.io/guides/examples/videos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/videos/</guid>
      <description>ipfs can be used to store and play videos. Suppose we add a video:
ipfs add -q sintel.mp4 | tail -n1  Take the resulting hash, You can view it a couple different ways:
On the command line:
ipfs cat $vidhash | mplayer -vo xv -  Via local gateway:
mplayer http://localhost:8080/ipfs/$vidhash # or open it up in a tab in chrome (or firefox) chromium http://localhost:8080/ipfs/$vidhash  (Note: the gateway method works with most video players and browsers)</description>
    </item>
    
    <item>
      <title>Playing with the Network</title>
      <link>https://docs.ipfs.io/guides/examples/network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/network/</guid>
      <description>IPFS is all about networking! Included are a useful set of commands to aid in observing the network.
See who you&amp;rsquo;re directly connected to:
ipfs swarm peers  Manually connect to a specific peer. If the peer below doesn&amp;rsquo;t work, choose one from the output of ipfs swarm peers.
ipfs swarm connect /ip4/104.236.176.52/tcp/4001/ipfs/QmSoLnSGccFuZQJzRadHn95W2CrSFmZuTdDWP8HXaHca9z  Search for a given peer on the network:
ipfs dht findpeer QmSoLnSGccFuZQJzRadHn95W2CrSFmZuTdDWP8HXaHca9z  By whyrusleeping</description>
    </item>
    
    <item>
      <title>Snapshots</title>
      <link>https://docs.ipfs.io/guides/examples/snapshots/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/snapshots/</guid>
      <description>Lets take a quick look at how ipfs can be used to take basic snapshots.
Save your directory:
$ ipfs add -r ~/code/myproject  Note the hash:
$ echo $hash `date` &amp;gt;&amp;gt; snapshots  Or all at once:
$ echo `ipfs add -q -r ~/code/myproject | tail -n1` `date` &amp;gt;&amp;gt; snapshots  (Note: the -q makes the output only contain the hashes, piping through tail -n1 ensures only the hash of the top folder is output.</description>
    </item>
    
    <item>
      <title>The Inter-Planetary Naming System</title>
      <link>https://docs.ipfs.io/guides/examples/ipns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/ipns/</guid>
      <description>ipns is a way to add a small amount of mutability to the permanent immutability that is ipfs. It allows you to store a reference to an ipfs hash under the namespace of your peerID ( the hash of your public key ). The commands to set it up are quite simple.
First, you&amp;rsquo;ll need some content to publish:
$ echo &#39;Let us have some mutable fun!&#39; | ipfs add  Note the hash that was printed out, and use it here to publish it to the network:</description>
    </item>
    
    <item>
      <title>Visualizing objects with graphmd</title>
      <link>https://docs.ipfs.io/guides/examples/graphmd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/graphmd/</guid>
      <description>When using ipfs for storing files, or writing more complex datastructures, it is often very useful to visualize the merkledag being created. For this, I wrote a simple tool called graphmd (graph merkle dag).
graphmd is a very short shell script (source). It uses the ipfs refs --format flag to produce dot output.
Install graphmd graphmd will be in its own repo soon, but for now you can install it with:</description>
    </item>
    
    <item>
      <title>操作分块</title>
      <link>https://docs.ipfs.io/guides/examples/blocks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/blocks/</guid>
      <description>ipfs add 命令会用你指定的文件中的数据创建一个默克有向无环图（Merkle DAG）。 它在执行时遵循 unixfs 数据格式。 这意味着你的文件会被分割成块，然后使用链接节点（link nodes）把它们以类似于树的结构组合起来。 给定文件的散列其实是 DAG 的根节点（顶部节点）的散列。 你可以使用 ipfs ls 轻易地查看一个给定 DAG 的子块。
例如：
# 确保这个文件大于 256k ipfs add alargefile ipfs ls thathash  上面的命令应该打印出类似如下内容：
ipfs@earth ~&amp;gt; ipfs ls qms2hjwx8qejwm4nmwu7ze6ndam2sfums3x6idwz5myzbn qmv8ndh7ageh9b24zngaextmuhj7aiuw3scc8hkczvjkww 7866189 qmuvjja4s4cgyqyppozttssquvgcv2n2v8mae3gnkrxmol 7866189 qmrgjmlhlddhvxuieveuuwkeci4ygx8z7ujunikzpfzjuk 7866189 qmrolalcquyo5vu5v8bvqmgjcpzow16wukq3s3vrll2tdk 7866189 qmwk51jygpchgwr3srdnmhyerheqd22qw3vvyamb3emhuw 5244129  这将显示文件的所有子块，以及它们及其子块在磁盘上的大小。
如何操作分块？ 如果你喜欢探索，你可以从这些不同的块中得到很多不同的信息。 你可以使用子块的散列作为 ipfs cat 的输入，只查看给定子树（那个块和它的子块）的数据。 若要只查看给定块的数据而不查看其子块，使用 ipfs block get。 但是要小心，因为直接对某个块使用 ipfs block get 会在屏幕上打印出 DAG 结构的原始二进制数据。
ipfs block stat 会告诉你一个给定块（不包括它的子块）的实际大小，ipfs refs 会告诉你一个块的所有子块。 类似地，ipfs ls 或 ipfs object links 会显示所有子块及它们的大小。 要编写在给定对象的每个子块上运行的脚本，ipfs refs 是一个更合适的命令。</description>
    </item>
    
    <item>
      <title>更加分布式的 Git</title>
      <link>https://docs.ipfs.io/guides/examples/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/git/</guid>
      <description>你有没有对自己说过：“伙计，我的 git 服务器不够分布式”或“我期望有一个简单的方法来提供全世界可用的静态 git 仓库”。 不用再期望了，我为你找到了解决方法！
在本文中，我将讨论如何使用 ipfs 网络提供 git 仓库服务。 最终的结果将是一个 ipfs 支撑的可以使用 git clone 的地址！
首先，选择你想要托管的那个 git 仓库，然后做一个它的裸克隆：
$ git clone --bare git@myhost.io/myrepo  如果你不了解 git，一个裸仓库表示它没有工作目录、可以作为服务器。 它的格式与一般的 git 仓库略有不同。
现在，为了让它准备好被克隆，你需要做以下操作：
$ cd myrepo $ git update-server-info  可选地，你可以解压所有 git 对象：
$ cp objects/pack/*.pack . $ git unpack-objects &amp;lt; ./*.pack $ rm ./*.pack  这样做会把 git 的大型打包文件分解为独立的对象。 如果你添加了这个存储库的多个版本，这会允许 ipfs 去除重复的对象。
当你做完后，那个仓库已经准备好提供服务了。 剩下要做的就是把它添加到 ipfs：
$ pwd /code/myrepo $ ipfs add -r .</description>
    </item>
    
    <item>
      <title>配置你的节点</title>
      <link>https://docs.ipfs.io/guides/examples/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.ipfs.io/guides/examples/config/</guid>
      <description>ipfs 是通过一个 json 格式文本文件配置的，这个文件默认位于 ~/.ipfs/config。
地址 配置文件里保存着数种不同类型的地址，他们都使用 multiaddr 地址格式。 下面我们看一下每个类型地址的含义。
&amp;quot;Addresses&amp;quot;: { &amp;quot;Swarm&amp;quot;: [ &amp;quot;/ip4/0.0.0.0/tcp/4001&amp;quot; ], &amp;quot;API&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/5001&amp;quot;, &amp;quot;Gateway&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/8080&amp;quot; }  集群 集群地址是本地守护程序将用来监听来自其他 ipfs 节点的链接的地址。 你应该确保这些地址可以从别的计算机连接，并且你指定的端口没有被防火墙阻止。
API API 地址是守护程序提供 http API 服务的地址。 这个 API 是用来通过命令行控制守护程序，如果你喜欢冒险，也可以直接通过 curl 进行控制。 你应该确保这个地址不能从你的机器以外访问，否则其他潜在的有恶意者可能能够向你的 ipfs 守护程序发送命令。
网关 网关地址是守护程序提供网关接口服务的地址。 网关可用于通过 ipfs 查看文件，并提供静态网页。 这个端口能与不能从外部访问完全取决于你。 网关地址是可选的，如果保持空白，网关服务器将不会启动。
挂载 如果没有用 ipfs mount 指定其他目录，那么挂载设置将指定 ipfs 和 ipns 虚拟文件系统的默认挂载点。 这些文件夹应该存在，并且你的用户应该有权限通过 fuse 挂载它们。
引导 引导配置数组指定了你的守护程序将会在启动时连接的 ipfs 节点列表。 默认值是‘ipfs solarnet’节点，它们是一组分布在全国各地的服务器。
By whyrusleeping</description>
    </item>
    
  </channel>
</rss>